#==========================================================================================+
|               MaterialPointVisualizer.jl: Post-processing for MPM in Julia               |
+------------------------------------------------------------------------------------------+
|  File Name  : hdf2pvd.jl                                                                 |
|  Description: convert h5 file into pvd animation in ParaView                             |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2025                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 1. animation() [2D & 3D]                                                   |
+==========================================================================================#

export animation

"""
    animation(conf::NamedTuple)

Description:
---
Generates animation by using the data from HDF5 file (2D/3D). 

`conf` is defined through [MaterialPointSolver.jl](https://github.com/LandslideSIM/MaterialPointSolver.jl) and 
by default includes the fields `prjdst` (project directory path) and `prjname` (project name). If the original `conf` 
is lost, please construct it yourself, for example: 

```julia
conf = (prjdst="path/to/your/project", prjname="project_name").
```

Note:
---
- Inside the function, use `prjdst/prjname.h5` as the path to the HDF5 file.
- This feature primarily provides animation support for HDF5 files generated by `MaterialPointSolver.jl`. 
If your HDF5 file is generated by other means, please refer to [WriteVTK.jl](https://github.com/JuliaVTK/WriteVTK.jl).
"""
@views function animation(conf::NamedTuple)
    @assert haskey(conf, :prjdst) "Missing `:prjdst` in conf"
    @assert isdir(getproperty(conf, :prjdst)) "`conf.prjdst` is not a valid directory"
    @assert haskey(conf, :prjname) "Missing `:prjname` in conf"
    h5_str = joinpath(conf.prjdst, "$(conf.prjname).h5")
    h5_file = isfile(h5_str) ? h5_str : throw(ArgumentError("Expected a h5 file path at $h5_str"))
    anim_path = joinpath(conf.prjdst, "animation"); mkpath(anim_path)
    #pvd = paraview_collection(joinpath(conf.prjdst, "$(conf.prjname).pvd"))
    fid = h5open(h5_file, "r")
    required = ("time", "ξ")
    groups = Tuple{String,Float64}[]
    @inbounds for gname in keys(fid)
        gname == "grid" && continue
        grp = fid[gname]
        all(haskey(grp, k) for k in required) || continue
        push!(groups, (gname, read(grp["time"])))
    end; sort!(groups, by = last)
    isempty(groups) && @warn "No valid time-step groups found in $h5_str"

    p = Progress(length(1:1:length(groups)) - 1; dt=3.0,
        desc      = "\e[1;36m[ Info:\e[0m writing",
        barlen    = 20,
        barglyphs = BarGlyphs(" ■■  ")
    )
    @inbounds Threads.@threads for igroup in eachindex(groups)
        grp = fid[groups[igroup][1]]
        coords = permutedims(read(grp["ξ"]))
        vtk_path = joinpath(anim_path, @sprintf("%08d", igroup))
        vtp_cls  = [MeshCell(PolyData.Verts(), [i]) for i in 1:size(coords, 2)]
        vtk_grid(vtk_path, coords, vtp_cls; compress=true, append=false, ascii=false) do vtk
            for name in keys(grp)
                name in ("ξ", "time") && continue
                data = read(grp[name])
                data = ndims(data) == 2 ? permutedims(data) : data
                vtk[name] = data
            end
        end
        next!(p)
    end
    _grid2vtr(fid, joinpath(conf.prjdst, "grid.vtr"))
    close(fid) # close HDF5 文件
    times = map(last, groups)  # 取出排序后的真实时间
    pvd_path = joinpath(conf.prjdst, "$(conf.prjname).pvd")
    _write_pvd(pvd_path, times; basedir="animation", ext=".vtp", part=0)
    return nothing
end

@views function _grid2vtr(fid, out_file::String)
    @assert haskey(fid, "grid") "HDF5 file does not contain group 'grid'"
    g = fid["grid"]
    h = read(g["h"])[]
    x1, x2 = read(g["x1"])[], read(g["x2"])[]
    y1, y2 = read(g["y1"])[], read(g["y2"])[]
    xs, ys = collect(x1:h:x2), collect(y1:h:y2)
    if haskey(g, "z1") && haskey(g, "z2")
        z1, z2  = read(g["z1"])[], read(g["z2"])[]
        zs = collect(z1:h:z2)
        vtr = vtk_grid(out_file, xs, ys, zs; compress=true, append=false, ascii=false)
    else
        vtr = vtk_grid(out_file, xs, ys; compress=true, append=false, ascii=false)
    end
    vtr["h"] = h
    close(vtr)
end

function _write_pvd(outpath::AbstractString, times::AbstractVector{<:Real};
                    basedir::AbstractString = "animation",
                    ext::AbstractString = ".vtp",
                    part::Integer = 0)
    open(outpath, "w") do io
        println(io, """<?xml version="1.0" encoding="utf-8"?>""")
        println(io, """<VTKFile type="Collection" version="1.0" byte_order="LittleEndian" compressor="vtkZLibDataCompressor">""")
        println(io, "  <Collection>")
        # 用 %.17g 写 timestep，既短又精确（避免 0.14749999999999996 这种串太长）
        for (i, t) in enumerate(times)
            step = @sprintf("%08d", i)
            tstr = @sprintf("%.17g", float(t))
            fileattr = string(basedir, "/", step, ext)  # 强制使用正斜杠，跨平台稳妥
            println(io, """    <DataSet timestep="$tstr" part="$part" file="$fileattr"/>""")
        end
        println(io, "  </Collection>")
        println(io, "</VTKFile>")
    end
    return outpath
end