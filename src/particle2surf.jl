#==========================================================================================+
|               MaterialPointVisualizer.jl: Post-processing for MPM in Julia               |
+------------------------------------------------------------------------------------------+
|  File Name  : particle2surf.jl                                                           |
|  Description: surface reconstruction for the MPM simulation                              |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2025                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 1. particle2ply                                                            |
|               2. ply2surface                                                             |
+==========================================================================================#

export particle2ply
export ply2surface

"""
    particle2ply(coords::Matrix; output_file::String="coord.ply")

Description:
---
Convert the particle coordinates (single array) to a PLY file.
"""
function particle2ply(coords::Matrix; output_file::String="coord.ply")
    # input validation
    size(coords, 2) in [2, 3] || throw(DimensionMismatch(
        "The input matrix should have 2 (2d) or 3 (3d) columns for the coordinates"))
    if !endswith(output_file, ".ply")
        output_file *= ".ply"
    end
    if size(coords, 2) == 2
        coords = hcat(coords, zeros(size(coords, 1)))
    end
    # export .ply file by using trimesh
    mesh = trimesh.Trimesh(vertices=coords)
    mesh.export(output_file)
    # print info
    @info """PLY file ($(size(coords, 1)) pts) saved at:
    $output_file"
    """
    return nothing
end

"""
    particle2ply(args::DeviceArgs2D, mp::DeviceParticle2D)

Description:
---
Convert the particle coordinates (data from MaterialPointSolver.jl) to a PLY file.
"""
function particle2ply(
    args::    DeviceArgs2D{T1, T2}, 
    mp  ::DeviceParticle2D{T1, T2}
) where {T1, T2}
    filename = args.project_name * ".ply"
    output_file = joinpath(args.project_path, args.project_name, filename)
    coords = hcat(mp.ξ, zeros(mp.np))
    # export .ply file by using trimesh
    mesh = trimesh.Trimesh(vertices=coords)
    mesh.export(output_file)
    # print info
    @info """PLY file ($(size(coords, 1)) pts) saved at:
    $output_file"
    """
    return nothing
end

"""
    particle2ply(args::DeviceArgs3D, mp::DeviceParticle3D)

Description:
---
Convert the particle coordinates (data from `MaterialPointSolver.jl`) to a `.ply` file.
"""
function particle2ply(
    args::    DeviceArgs3D{T1, T2}, 
    mp  ::DeviceParticle3D{T1, T2}
) where {T1, T2}
    filename = args.project_name * ".ply"
    output_file = joinpath(args.project_path, args.project_name, filename)
    # export .ply file by using trimesh
    mesh = trimesh.Trimesh(vertices=mp.ξ)
    mesh.export(output_file)
    # print info
    @info """PLY file ($(mp.np) pts) saved at:
    $output_file"
    """
    return nothing
end

"""
    particle2ply(hdf5_file::String, ply_dir::String)

Description:
---
Convert the particle coordinates (data from HDF5 file, which is generated by 
`MaterialPointSolver.jl`) to a `.ply` file.
"""
function particle2ply(hdf5_file::String, ply_dir::String)
    hdf5_dir = dirname(hdf5_file)
    hdf5_dir == ply_dir && throw(ArgumentError(
        "The HDF5 file and ply output directories should be different"))
    isdir(ply_dir) || mkpath(ply_dir)
    fid = h5open(hdf5_file, "r")
    itr = (read(fid["FILE_NUM"])-1) |> Int64
    p = Progress(length(1:1:itr)-1; 
        desc      = "\e[1;36m[ Info:\e[0m $(lpad("ply_gen", 7))",
        color     = :white,
        barlen    = 12,
        barglyphs = BarGlyphs(" ◼◼  "))
    @inbounds for i in 1:itr
        obj = Float32.(fid["group$(i)/coords"] |> read)
        if size(obj, 2) == 2
            obj = hcat(obj, zeros(size(obj, 1)))
        end
        output_file = joinpath(ply_dir, "iteration_$(i).ply")
        # export .ply file by using trimesh
        mesh = trimesh.Trimesh(vertices=obj)
        mesh.export(output_file)
        next!(p)
    end
    close(fid)
    @info """PLY files saved at:
    $ply_dir
    """
    return nothing
end

"""
    ply2surface(ply_dir, splash_dir, radius, num_threads; cube_size=0.6, 
        surface_threshold=0.6, smoothing_length=1.2, splashsurf="nothing")

Description:
---
- radius: particle (primitive) radius should be half of the particle's diameter. 
- smoothing-length: It should be set around 1.2. The larger the value, the smoother the isosurface, but it will also artificially increase the fluid volume. 
- surface-threshold: It can be used to offset the increase in fluid volume caused by factors such as larger particle radius, and a threshold of 0.6 seems to work quite well. 
- cube-size: Typically, it should not exceed 1. If the results are rough or the runtime is long, start increasing or decreasing from between 0.5 to 0.75. 

---

- 半径：粒子(原始)半径，应该是粒子直径的一半
- 光滑长度：应围绕1.2设置。值越大，等值面越平滑，但也会人为地增加流体体积
- 表面阈值：可以用来抵消由于较大粒子半径等因素导致的流体体积增加,0.6的阈值似乎效果不错
- 立方体尺寸：通常不能大于1,如果结果粗糙或者运行时间长,从0.5~0.75之间开始增大或减小
"""
function ply2surface(
    ply_dir, 
    splash_dir,
    radius,
    num_threads;
    cube_size          = 0.6,
    surface_threshold  = 0.6, 
    smoothing_length   = 1.2,
    splashsurf::String = "nothing"
)
    if splashsurf == "nothing"
        try
            run(pipeline(`splashsurf -V`, stdout=devnull, stderr=devnull))
        catch e
            if isa(e, Base.IOError)  # splashsurf 未安装
                @warn """splashsurf
                Cannot find splashsurf on this system. If you need surface reconstruction, please
                install it first, and make sure Julia can find it.
                Or you can pass the path of splashsurf to ply2surface.
                link: https://github.com/InteractiveComputerGraphics/splashsurf 
                """
            end
        end
        splashsurfcmd = "splashsurf"
    else
        try
            run(pipeline(`$(splashsurf) -V`, stdout=devnull, stderr=devnull))
        catch e
            if isa(e, Base.IOError)  # splashsurf 未安装
                @warn """invalid splashsurf path
                Cannot find splashsurf on this system. If you need surface reconstruction, please
                install it first, and make sure Julia can find it.
                Or you can pass the path of splashsurf to ply2surface.
                link: https://github.com/InteractiveComputerGraphics/splashsurf 
                """
            end
        end
        splashsurfcmd = splashsurf
    end

    num_threads = 1 ≤ num_threads ≤ Sys.CPU_THREADS ? num_threads : Sys.CPU_THREADS
    splash_dir ≠ ply_dir || throw(ArgumentError(
        "The splash output directory should be different from the ply input directory"))
    isdir(splash_dir) || mkpath(splash_dir)
    if isfile(ply_dir)
        inputs = ply_dir
        outputs = joinpath(splash_dir, "surface.vtk")
        run(`$(splashsurfcmd) reconstruct $(inputs) --output-file=$(outputs)
            --particle-radius=$(radius*1.5)
            --cube-size=$(cube_size)
            --surface-threshold=$(surface_threshold)
            --smoothing-length=$(smoothing_length)
            --subdomain-grid=on
            --mesh-cleanup=on
            --mesh-smoothing-weights=on 
            --mesh-smoothing-iters=25 
            --normals=on
            --normals-smoothing-iters=10`
        )
    elseif isdir(ply_dir)
        inputs = joinpath(ply_dir, "iteration_{}.ply")
        outputs = joinpath(splash_dir, "iteration_{}.vtk")
        run(`$(splashsurfcmd) reconstruct $(inputs) --output-file=$(outputs)
            --particle-radius=$(radius*1.5)
            --cube-size=$(cube_size)
            --surface-threshold=$(surface_threshold)
            --smoothing-length=$(smoothing_length)
            --subdomain-grid=on
            --mesh-cleanup=on
            --mesh-smoothing-weights=on 
            --mesh-smoothing-iters=25 
            --normals=on
            --normals-smoothing-iters=10
            --mt-particles=off
            --num-threads=$(num_threads)
            --mt-files=on`
        )
    end
    @info "reconstructed surfaces have been saved to $splash_dir"
    return nothing
end