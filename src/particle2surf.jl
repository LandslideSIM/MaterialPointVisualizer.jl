#==========================================================================================+
|               MaterialPointVisualizer.jl: Post-processing for MPM in Julia               |
+------------------------------------------------------------------------------------------+
|  File Name  : particle2surf.jl                                                           |
|  Description: surface reconstruction for the MPM simulation                              |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2025                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 1. particle2ply                                                            |
|               2. ply2surface                                                             |
+==========================================================================================#

export particle2ply
export ply2surface

"""
    particle2ply(coords::Matrix; output_file::String="coord.ply")

Description:
---
Convert the particle coordinates (single array) to a PLY file.
"""
@views function particle2ply(coords::Matrix; output_file::String="coord.ply")
    size(coords, 2) == 3 || throw(DimensionMismatch(
        "The input matrix should have 3 columns for x, y, and z coordinates"))
    pts_num = size(coords, 1)
    coords .= Float32.(coords)
    ply = Ply()
    vertex = PlyElement("vertex",
            ArrayProperty("x", coords[:, 1]),
            ArrayProperty("y", coords[:, 2]),
            ArrayProperty("z", coords[:, 3]))
    push!(ply, vertex)
    save_ply(ply, output_file, ascii=false)
    @info "$pts_num particles have been saved to $output_file"
    return nothing
end

"""
    particle2ply(args::DeviceArgs2D, mp::DeviceParticle2D)

Description:
---
Convert the particle coordinates (data from MaterialPointSolver.jl) to a PLY file.
"""
@views function particle2ply(
    args::    DeviceArgs2D{T1, T2}, 
    mp  ::DeviceParticle2D{T1, T2}
) where {T1, T2}
    ply = Ply()
    vertex = PlyElement("vertex",
            ArrayProperty("x", Float32.(mp.ξ[:, 1])),
            ArrayProperty("y", Float32.(mp.ξ[:, 2])),
            ArrayProperty("z", zeros(Float32, mp.np)))
    push!(ply, vertex)
    filename = args.project_name * ".ply"
    output_file = joinpath(args.project_path, args.project_name, filename)
    save_ply(ply, output_file, ascii=false)
    @info "$pts_num particles have been saved to $output_file"
    return nothing
end

"""
    particle2ply(args::DeviceArgs3D, mp::DeviceParticle3D)

Description:
---
Convert the particle coordinates (data from `MaterialPointSolver.jl`) to a `.ply` file.
"""
@views function particle2ply(
    args::    DeviceArgs3D{T1, T2}, 
    mp  ::DeviceParticle3D{T1, T2}
) where {T1, T2}
    ply = Ply()
    vertex = PlyElement("vertex",
            ArrayProperty("x", Float32.(mp.ξ[:, 1])),
            ArrayProperty("y", Float32.(mp.ξ[:, 2])),
            ArrayProperty("z", Float32.(mp.ξ[:, 3])))
    push!(ply, vertex)
    filename = args.project_name * ".ply"
    output_file = joinpath(args.project_path, args.project_name, filename)
    save_ply(ply, output_file, ascii=false)
    @info "$pts_num particles have been saved to $output_file"
    return nothing
end

"""
    particle2ply(hdf5_file::String, ply_dir::String)

Description:
---
Convert the particle coordinates (data from HDF5 file, which is generated by 
`MaterialPointSolver.jl`) to a `.ply` file.
"""
@views function particle2ply(hdf5_file::String, ply_dir::String)
    hdf5_dir = dirname(hdf5_file)
    hdf5_dir == ply_dir && throw(ArgumentError(
        "The HDF5 file and ply output directories should be different"))
    rm(ply_dir, recursive=true, force=true); mkpath(ply_dir)
    fid = h5open(hdf5_file, "r")
    itr = (read(fid["FILE_NUM"])-1) |> Int64
    p = Progress(length(1:1:itr)-1; 
        desc      = "\e[1;36m[ Info:\e[0m $(lpad("ply_gen", 7))",
        color     = :white,
        barlen    = 12,
        barglyphs = BarGlyphs(" ◼◼  "))
    @inbounds for i in 1:itr
        obj = Float32.(fid["group$(i)/coords"] |> read)
        vertex = PlyElement("vertex",
            ArrayProperty("x", obj[:, 1]),
            ArrayProperty("y", obj[:, 2]),
            ArrayProperty("z", obj[:, 3]))
        ply = Ply(); push!(ply, vertex)
        save_ply(ply, joinpath(ply_dir, "iteration_$(i).ply"), ascii=false)
        next!(p)
    end
    close(fid)
    @info "particle files have been saved to $ply_dir"
    return nothing
end

"""
    ply2surface(ply_dir, splash_dir, radius, num_threads; cube_size=0.6, 
        surface_threshold=0.6, smoothing_length=1.2)

Description:
---
- radius: particle (primitive) radius should be half of the particle's diameter. 
- smoothing-length: It should be set around 1.2. The larger the value, the smoother the isosurface, but it will also artificially increase the fluid volume. 
- surface-threshold: It can be used to offset the increase in fluid volume caused by factors such as larger particle radius, and a threshold of 0.6 seems to work quite well. 
- cube-size: Typically, it should not exceed 1. If the results are rough or the runtime is long, start increasing or decreasing from between 0.5 to 0.75. 

---

- 半径：粒子(原始)半径，应该是粒子直径的一半
- 光滑长度：应围绕1.2设置。值越大，等值面越平滑，但也会人为地增加流体体积
- 表面阈值：可以用来抵消由于较大粒子半径等因素导致的流体体积增加,0.6的阈值似乎效果不错
- 立方体尺寸：通常不能大于1,如果结果粗糙或者运行时间长,从0.5~0.75之间开始增大或减小
"""
function ply2surface(
    ply_dir, 
    splash_dir,
    radius,
    num_threads;
    cube_size        =0.6,
    surface_threshold=0.6, 
    smoothing_length =1.2
)
    num_threads = 1 ≤ num_threads ≤ Sys.CPU_THREADS ? num_threads : Sys.CPU_THREADS
    splash_dir ≠ ply_dir || throw(ArgumentError(
        "The splash output directory should be different from the ply input directory"))
    rm(splash_dir, recursive=true, force=true); mkpath(splash_dir)
    if ply_dir[end-3:end] == ".ply"
        inputs = ply_dir
        outputs = joinpath(splash_dir, "surface.vtk")
        run(`splashsurf reconstruct $(inputs) --output-file=$(outputs)
            --particle-radius=$(radius*1.5)
            --cube-size=$(cube_size)
            --surface-threshold=$(surface_threshold)
            --smoothing-length=$(smoothing_length)
            --subdomain-grid=on
            --mesh-cleanup=on
            --mesh-smoothing-weights=on 
            --mesh-smoothing-iters=25 
            --normals=on
            --normals-smoothing-iters=10`
        )
    else
        inputs = joinpath(ply_dir, "iteration_{}.ply")
        outputs = joinpath(splash_dir, "iteration_{}.vtk")
        run(`splashsurf reconstruct $(inputs) --output-file=$(outputs)
            --particle-radius=$(radius*1.5)
            --cube-size=$(cube_size)
            --surface-threshold=$(surface_threshold)
            --smoothing-length=$(smoothing_length)
            --subdomain-grid=on
            --mesh-cleanup=on
            --mesh-smoothing-weights=on 
            --mesh-smoothing-iters=25 
            --normals=on
            --normals-smoothing-iters=10
            --mt-particles=off
            --num-threads=$(num_threads)
            --mt-files=on`
        )
    end
    @info "reconstructed surfaces have been saved to $splash_dir"
    return nothing
end