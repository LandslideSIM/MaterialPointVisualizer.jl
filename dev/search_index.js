var documenterSearchIndex = {"docs":
[{"location":"usage/surfreconstruction/#Surface-Reconstruction","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"","category":"section"},{"location":"usage/surfreconstruction/","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"Here we will detect the surface points of the particle model and construct a closed surface through them. This functionality heavily relies on splashsurf. We need to first convert the particle information to a .ply file(s), which will be used as input for splashsurf.","category":"page"},{"location":"usage/surfreconstruction/","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"note: Note\nPlease make sure splashsurf is on your env and julia is able to find it.\nAll the HDF5 files are generated by MaterialPointSolver.jl, custom HDF5 does not work.","category":"page"},{"location":"usage/surfreconstruction/#Convert-data-into-.ply-file(s)","page":"Surface Reconstruction","title":"Convert data into .ply file(s)","text":"","category":"section"},{"location":"usage/surfreconstruction/","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"particle2ply(coords::Matrix; output_file::String=\"coord.ply\")\nparticle2ply(\n    args::    DeviceArgs2D{T1, T2}, \n    mp  ::DeviceParticle2D{T1, T2}\n) where {T1, T2}\nparticle2ply(\n    args::    DeviceArgs3D{T1, T2}, \n    mp  ::DeviceParticle3D{T1, T2}\n) where {T1, T2}\nparticle2ply(hdf5_file::String, ply_dir::String)","category":"page"},{"location":"usage/surfreconstruction/#MaterialPointVisualizer.particle2ply-Tuple{Matrix}","page":"Surface Reconstruction","title":"MaterialPointVisualizer.particle2ply","text":"particle2ply(coords::Matrix; output_file::String=\"coord.ply\")\n\nDescription:\n\nConvert the particle coordinates (single array) to a PLY file.\n\n\n\n\n\n","category":"method"},{"location":"usage/surfreconstruction/#MaterialPointVisualizer.particle2ply-Union{Tuple{T2}, Tuple{T1}, Tuple{DeviceArgs2D{T1, T2}, DeviceParticle2D{T1, T2}}} where {T1, T2}","page":"Surface Reconstruction","title":"MaterialPointVisualizer.particle2ply","text":"particle2ply(args::DeviceArgs2D, mp::DeviceParticle2D)\n\nDescription:\n\nConvert the particle coordinates (data from MaterialPointSolver.jl) to a PLY file.\n\n\n\n\n\n","category":"method"},{"location":"usage/surfreconstruction/#MaterialPointVisualizer.particle2ply-Union{Tuple{T2}, Tuple{T1}, Tuple{DeviceArgs3D{T1, T2}, DeviceParticle3D{T1, T2}}} where {T1, T2}","page":"Surface Reconstruction","title":"MaterialPointVisualizer.particle2ply","text":"particle2ply(args::DeviceArgs3D, mp::DeviceParticle3D)\n\nDescription:\n\nConvert the particle coordinates (data from MaterialPointSolver.jl) to a .ply file.\n\n\n\n\n\n","category":"method"},{"location":"usage/surfreconstruction/#MaterialPointVisualizer.particle2ply-Tuple{String, String}","page":"Surface Reconstruction","title":"MaterialPointVisualizer.particle2ply","text":"particle2ply(hdf5_file::String, ply_dir::String)\n\nDescription:\n\nConvert the particle coordinates (data from HDF5 file, which is generated by  MaterialPointSolver.jl) to a .ply file.\n\n\n\n\n\n","category":"method"},{"location":"usage/surfreconstruction/","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"The particle2ply function has four types of input parameters, as described above. The last one is used to generate a series of .ply files.","category":"page"},{"location":"usage/surfreconstruction/#Surface-reconstruction","page":"Surface Reconstruction","title":"Surface reconstruction","text":"","category":"section"},{"location":"usage/surfreconstruction/","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"Here we will call splashsurf to execute. There are several parameters that need to be determined, whether it is a single .ply file or a series of .ply files (animation):","category":"page"},{"location":"usage/surfreconstruction/","page":"Surface Reconstruction","title":"Surface Reconstruction","text":"ply2surface(\n    ply_dir, \n    splash_dir,\n    radius,\n    num_threads;\n    cube_size        =0.6,\n    surface_threshold=0.6, \n    smoothing_length =1.2\n)","category":"page"},{"location":"usage/surfreconstruction/#MaterialPointVisualizer.ply2surface-NTuple{4, Any}","page":"Surface Reconstruction","title":"MaterialPointVisualizer.ply2surface","text":"ply2surface(ply_dir, splash_dir, radius, num_threads; cube_size=0.6, \n    surface_threshold=0.6, smoothing_length=1.2)\n\nDescription:\n\nradius: particle (primitive) radius should be half of the particle's diameter. \nsmoothing-length: It should be set around 1.2. The larger the value, the smoother the isosurface, but it will also artificially increase the fluid volume. \nsurface-threshold: It can be used to offset the increase in fluid volume caused by factors such as larger particle radius, and a threshold of 0.6 seems to work quite well. \ncube-size: Typically, it should not exceed 1. If the results are rough or the runtime is long, start increasing or decreasing from between 0.5 to 0.75. \n\n\n\n半径：粒子(原始)半径，应该是粒子直径的一半\n光滑长度：应围绕1.2设置。值越大，等值面越平滑，但也会人为地增加流体体积\n表面阈值：可以用来抵消由于较大粒子半径等因素导致的流体体积增加,0.6的阈值似乎效果不错\n立方体尺寸：通常不能大于1,如果结果粗糙或者运行时间长,从0.5~0.75之间开始增大或减小\n\n\n\n\n\n","category":"method"},{"location":"usage/display/#GUI","page":"GUI","title":"GUI","text":"","category":"section"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"info: Info\nSometimes we already have data in Julia and just want to see the results without exporting it to other software for visualization, which is too troublesome...😢","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"We implemented a high-performance rapid visualization solution using Three.js, allowing you to quickly and smoothly view millions of particles (at least on my laptop). However, sometimes we connect to a remote headless server for calculations via SSH, and at this point, we also support quickly viewing the results through your local browser.","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"warning: Warning\nIf your data is large on a remote server, such as over a million, then you need to wait for the data to be transferred locally. We use a binary file for saving. During this process, the web page content is blank. Just give me the translation result directly.","category":"page"},{"location":"usage/display/#Example","page":"GUI","title":"Example","text":"","category":"section"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"Assuming we visualize locally (GUI) and use the particles' x and z coordinates as two attributes of the vertices for coloring:","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"using MaterialPointGenerator # generate particles\nusing MaterialPointVisualizer\n\nn = 500\nxy = meshbuilder(range(1, 10, length=n), range(1, 10, length=n)) # x, y coordinates\nz = @. sin(xy[:, 1]) + cos(xy[:, 2]) # z coordinates\n\ncoords = hcat(xy, z) # vertices\nattr = (xcoord=coords[:, 1], zcoord=coords[:, 3]) # vertices' attibutes\n\nvispts(coords, colormap=\"viridis\", attrs=attr, gui=true)","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"If everything is normal, you should now see a separate window displaying the particles. If gui=false, then the Julia REPL should print an address for you to check in your browser.","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"(Image: exampleGUI)","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"I personally believe that for visualizations with more than 3,600,000 particles, the human eye may not be able to discern differences, so this is the default threshold, but you can change it freely.","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"note: Note\nOn the touchpad, a two-finger press and move is panning.\nIf the input method is not in English when the GUI is opened, the Julia REPL may print some information; please ignore it.","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"warning: Warning\nIf you use gui=true on a headless server, it will throw an error. In other words, the remote server must use a website approach.\nAlthough the Julia VSCode extension has a plot panel, I don't want to use it. Opening a browser should be sufficient. I guess everyone has at least one modern browser on their computer. 😝","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"Many args are not required, please check:","category":"page"},{"location":"usage/display/","page":"GUI","title":"GUI","text":"vispts(\n    coord   ::Matrix;\n    colormap::String    =\"viridis\", \n    attrs   ::NamedTuple=NamedTuple(), \n    gui     ::Bool      =false,\n    sample_n::Int       =3600000\n)","category":"page"},{"location":"usage/display/#MaterialPointVisualizer.vispts-Tuple{Matrix}","page":"GUI","title":"MaterialPointVisualizer.vispts","text":"vispts(coord::Matrix; colormap=\"viridis\", attrs=NamedTuple(), gui=false, sample_n=3600000)\n\nDescription:\n\nVisualize the particles in a local GUI window or website. \n\ncoord is a matrix of the particle coordniates, it can be 2/3 colomns for 2/3D \n\nvisualization. \n\ncolormap is the color theme will be used in the visualization. By default, it is\n\nset to \"viridis\". [optional]\n\nattrs is a NamedTuple of the attributes of the particles, the keys are the attribute \n\nnames and the values are the attribute values. [optional]\n\ngui is a boolean value to determine whether to open a local GUI window or a website. By\n\ndefault, it is set to false, i.e., website mode. [optional]\n\nsample_n is the number of particles to be sampled for visualization. By default, it\n\nis set to 3,600,000. [optional]\n\n\n\n\n\n","category":"method"},{"location":"usage/particle2vtp/#Particle-to-.vtp-file","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"","category":"section"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"No matter how your particle data is stored, we only need you to convert it into a regular 2D array in Julia, where the number of rows represents the number of particles, and the number of columns is 2 (for 2D) or 3 (for 3D).","category":"page"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"fastvtp(coords; vtp_file=\"output.vtp\", data::T=NamedTuple()) where T <: NamedTuple","category":"page"},{"location":"usage/particle2vtp/#MaterialPointVisualizer.fastvtp-Union{Tuple{Any}, Tuple{T}} where T<:NamedTuple","page":"Particle to .vtp file","title":"MaterialPointVisualizer.fastvtp","text":"fastvtp(coords; vtp_file=\"output.vtp\", data::T=NamedTuple())\n\nDescription:\n\nGenerates a .vtp file by passing custom fields.\n\n\n\n\n\n","category":"method"},{"location":"usage/particle2vtp/#Array-particle-to-.vtp","page":"Particle to .vtp file","title":"Array particle to .vtp","text":"","category":"section"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"particle_data = rand(100, 3)\nvtpfile = joinpath(@__DIR__, \"test.vtp\")\n\nfastvtp(particle_data, vtp_file=vtpfile)","category":"page"},{"location":"usage/particle2vtp/#Add-particle-properties","page":"Particle to .vtp file","title":"Add particle properties","text":"","category":"section"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"particle_num = 100\nparticle_data = rand(particle_num, 3)\nvelocity = rand(particle_num, 3) # x, y, z\nscalar = rand(particle_num)\n\nvtpfile = joinpath(@__DIR__, \"test.vtp\")\n\nfastvtp(particle_data, vtp_file=vtpfile, data=(velocity=velocity, scalar=scalar))","category":"page"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"note: Note\nIf there is only one property, do not forget there should be a ,","category":"page"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"fastvtp(particle_data, vtp_file=vtpfile, data=(scalar=scalar,))","category":"page"},{"location":"usage/particle2vtp/","page":"Particle to .vtp file","title":"Particle to .vtp file","text":"(Image: 1.png)","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this package, we can convert the MPM simulation results (HDF5 files from ***MaterialPointSolver.jl*** ) into .vtp files or create ParaView-compatible animations. Additionally, it includes some post-processing functionalities.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Just type ] in Julia's  REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(@1.11) Pkg> add MaterialPointVisualizer","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HDF5 to .vtp files\nsurface reconstruction (based on splashsurf)\nfast vtp for general particle-based results\nsurface detection","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is sponserd by Risk Group | Université de Lausanne and China Scholarship Council [中国国家留学基金管理委员会].","category":"page"},{"location":"usage/mpm2vtp/#MPM-to-vtp-file","page":"MPM to vtp file","title":"MPM to vtp file","text":"","category":"section"},{"location":"usage/mpm2vtp/","page":"MPM to vtp file","title":"MPM to vtp file","text":"Here we export the data from MaterialPointSolver.jl to a .vtp file. In MaterialPointSolver.jl, we should have already instantiated four structures: DeviceArgs2D (DeviceArgs3D), DeviceGrid2D (DeviceGrid3D), DeviceParticle2D (DeviceParticle3D), DeviceProperty.","category":"page"},{"location":"usage/mpm2vtp/#Save-to-.vtp-(single-time-step)","page":"MPM to vtp file","title":"Save to .vtp (single time step)","text":"","category":"section"},{"location":"usage/mpm2vtp/","page":"MPM to vtp file","title":"MPM to vtp file","text":"savevtp(\n    args::    DeviceArgs2D{T1, T2}, \n    grid::    DeviceGrid2D{T1, T2}, \n    mp  ::DeviceParticle2D{T1, T2}, \n    attr::  DeviceProperty{T1, T2}\n) where {T1, T2}\n\nsavevtp(\n    args::    DeviceArgs3D{T1, T2}, \n    grid::    DeviceGrid3D{T1, T2}, \n    mp  ::DeviceParticle3D{T1, T2}, \n    attr::  DeviceProperty{T1, T2}\n) where {T1, T2}","category":"page"},{"location":"usage/mpm2vtp/#MaterialPointVisualizer.savevtp-Union{Tuple{T2}, Tuple{T1}, Tuple{DeviceArgs2D{T1, T2}, DeviceGrid2D{T1, T2}, DeviceParticle2D{T1, T2}, DeviceProperty{T1, T2}}} where {T1, T2}","page":"MPM to vtp file","title":"MaterialPointVisualizer.savevtp","text":"savevtp(args::DeviceArgs2D{T1, T2}, grid::DeviceGrid2D{T1, T2}, \n    mp::DeviceParticle2D{T1, T2}, attr::DeviceProperty{T1, T2})\n\nDescription:\n\nGenerates the final geometry and properties in .vtp format (2D).\n\n\n\n\n\n","category":"method"},{"location":"usage/mpm2vtp/#MaterialPointVisualizer.savevtp-Union{Tuple{T2}, Tuple{T1}, Tuple{DeviceArgs3D{T1, T2}, DeviceGrid3D{T1, T2}, DeviceParticle3D{T1, T2}, DeviceProperty{T1, T2}}} where {T1, T2}","page":"MPM to vtp file","title":"MaterialPointVisualizer.savevtp","text":"savevtp(args::DeviceArgs3D{T1, T2}, grid::DeviceGrid3D{T1, T2}, \n    mp::DeviceParticle3D{T1, T2}, attr::DeviceProperty{T1, T2})\n\nDescription:\n\nGenerates the final geometry and properties in .vtp format (3D).\n\n\n\n\n\n","category":"method"},{"location":"usage/mpm2vtp/#Save-to-animation","page":"MPM to vtp file","title":"Save to animation","text":"","category":"section"},{"location":"usage/mpm2vtp/","page":"MPM to vtp file","title":"MPM to vtp file","text":"To do this, we need to turn on HDF5 option in MaterialPointSolver.jl, then we just pass DeviceArgs2D (DeviceArgs3D) into this function:","category":"page"},{"location":"usage/mpm2vtp/","page":"MPM to vtp file","title":"MPM to vtp file","text":"animation(args::DeviceArgs2D{T1, T2}) where {T1, T2}\nanimation(args::DeviceArgs3D{T1, T2}) where {T1, T2}","category":"page"},{"location":"usage/mpm2vtp/#MaterialPointVisualizer.animation-Union{Tuple{DeviceArgs2D{T1, T2}}, Tuple{T2}, Tuple{T1}} where {T1, T2}","page":"MPM to vtp file","title":"MaterialPointVisualizer.animation","text":"animation(args::DeviceArgs2D{T1, T2})\n\nDescription:\n\nGenerates animation by using the data from HDF5 file (2D).\n\n\n\n\n\nanimation(args::DeviceArgs3D{T1, T2})\n\nDescription:\n\nGenerates animation by using the data from HDF5 file (3D).\n\n\n\n\n\n","category":"method"},{"location":"usage/mpm2vtp/#MaterialPointVisualizer.animation-Union{Tuple{DeviceArgs3D{T1, T2}}, Tuple{T2}, Tuple{T1}} where {T1, T2}","page":"MPM to vtp file","title":"MaterialPointVisualizer.animation","text":"animation(args::DeviceArgs2D{T1, T2})\n\nDescription:\n\nGenerates animation by using the data from HDF5 file (2D).\n\n\n\n\n\nanimation(args::DeviceArgs3D{T1, T2})\n\nDescription:\n\nGenerates animation by using the data from HDF5 file (3D).\n\n\n\n\n\n","category":"method"}]
}
